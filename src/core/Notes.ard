

-- Defining Data types

-- data type with 3 constructors
\data T | c1 | c2 | c3

-- data type where constructors have arguments
\data T2 | c4 Int | c5 Bool | c6 Int Bool

-- data type with at type parameter
\data T3 \Type | c7 | c8

\func ex_T3 : T3 Int => c7

-- binding the type parameter to a literal to use in construtors
\data T4 (A : \Type) | c9 | c10 A

\func ex_T4 : T4 Nat => c10 8








-- Defining functions

-- All functions in Arend must be total and terminate.

-- constant functions or values
\func ex_val : Int => 7

-- function with explicit parameters
\func ex_fun (a : Int) : Int => a

-- function with an implicit type parameter and an explicit value parameter
\func id {A : \Type} (a : A) : A => a
\func ex_id : Int => id 8

-- function defined with pattern matching
\func not (b : Bool) : Bool
  | true => false
  | false => true

-- equivalently
\func not' (b : Bool) : Bool \elim b
  | true => false
  | false => true


-- chosing the argument to pattern match on
\func if {A : \Type} (b : Bool) (t e : A) : A \elim b
  | true => t
  | false => e

-- lambdas
\func ex_lambda {A : \Type} : A -> Int => \lam (a : A) => 7



-- Defining a typeclass (haskell style typeclasses)


\class Lucky (A : \Type ) {
  | roll : A -> Int
}

-- Defining an instance
\data Dice | die

\instance Lucky-Dice : Lucky Dice
  | roll => \lam _ => 5





-- Equality Type

{-
  Equality is a complex topic in Arend, but we will keep it simple here.

  For some type A and a : A, there is a type a = a

  This is an example of a dependent type. There is a value in the Type.
  ex)
    Bool has two terms: True, False.

    So there are 2 types,
      True = True
      and
      False = False

  How do you construct a term of this type?

  There is a built in term `idp`.

  ex)
 -}

\func true_eq_true : true = true => idp
\func false_eq_fasle : false = false => idp

-- idp represents the reflexive property of equality, for all a : A, a is always equal to itself.
-- you could call if `reflexivity` or `refl` for short if you like

\func reflexivity {A : \Type} (a : A) : a = a => idp

\func simple_fact : 2 = 2 => reflexivity 2


-- idp can also relate two equal terms that are equivalent by computation (definitional equality)
-- for example,  not (true) reduces to false
-- so we can use `idp` to equate not (true) and false

\func not_true_eq_false : not true = false => idp

-- another classic example using addition
-- 2 + 2 reduces to 4 by computaiton, so we can equate 2 + 2 and 4

\func simple_math : (2 Nat.+ 2) = 4 => idp


{- with that, we can enhance our lucky typclass to be more specific!
   the implementation of the roll function must result in 7 every time
 -}

\class Lucky' (A : \Type)
  -- a roll function maps all constructors of A to an integer
  | roll : A -> Int
  -- all rolls must result in 7! how lucky!
  | lucky_roll (a : A) : roll a = 7


\instance Lucky-Dice' : Lucky' Dice
  -- here we define the roll function to be a constant lambda, 7
  | roll => \lam _ => 7
  -- and we prove that all rolls result in 7 using `idp`
  | lucky_roll (d : Dice) => idp